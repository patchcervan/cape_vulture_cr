
## 4. Model comparison

To compare models we take a 200 km radius buffer around each bird's colony. Then, with the different model outputs we generate predictions and contrast these with the observed locations. The different steps are the following:

 1. Choose a target bird to make predictions about.
 
 
```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='75%', fig.align='center', fig.show='hold'}

# Choose one bird
id_sel <- "wt07"
trk <- test_data$data[which(test_data$bird_id == id_sel)][[1]]

trk <- st_transform(trk, crs = 4326)

plot(st_geometry(trk), axes = T)
title(id_sel)


```


 2. Find its colony and define a 200 km buffer around.
 
 3. Set raster covariates for the area
 
```{r, echo=FALSE, warning=FALSE, message=FALSE}

# Find colony
colony <- test_data$colony[which(test_data$bird_id == id_sel)][[1]]

av_area <- st_buffer(colony, dist = 200000)

# Reproject colony and availabe area
colony <- st_transform(colony, crs = 4326)
av_area <- st_transform(av_area, crs = 4326)

# Load covariates
source(paste0(proj_path, "/R/functions/loadCovtsRasters.R"))

covts_path = paste0(proj_path, "/data/working/covts_rasters")

srtm <- loadCovts(av_area, covts_path = covts_path, covt = "srtm")
slope <- loadCovts(av_area, covts_path = covts_path, covt = "slope")
vrm3 <- loadCovts(av_area, covts_path = covts_path, covt = "vrm3")

# crop covariates
future::plan("multiprocess")
srtm <- future_map(srtm, ~crop(.x, av_area))
slope <- future_map(slope, ~crop(.x, av_area))
vrm3 <- future_map(vrm3, ~crop(.x, av_area))


if(length(srtm) > 1){
    srtm <- do.call(raster::merge, srtm)
    slope <- do.call(raster::merge, slope)
    vrm3 <- do.call(raster::merge, vrm3)
} else{
    srtm <- srtm[[1]]
    slope <- slope[[1]]
    vrm3 <- vrm3[[1]]
}

future::plan("sequential") # It's important to close multiprocess after merge otherwise temp files are lost

# Calculate distance
dist <- raster::distanceFromPoints(srtm, st_coordinates(colony))

```

 
```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='50%', fig.align='center', fig.show='hold'}

# Plot covariates

plot(srtm, col = terrain.colors(50)); title("Elevation")
plot(slope, col = topo.colors(50, rev = T)); title("Slope")
plot(vrm3, col = viridis::magma(50, direction = -1)); title("VRM *ruggedness")
plot(dist, col = viridis::cividis(50, direction = -1)); title("Distance from colony")


```


    4. Choose a model and a bird to predict from (e.g. RSF_home_range fitted to "ma14")
    
    5. Predict over the range of the covariates
    
 
```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='75%', fig.align='center', fig.show='hold'}

# Choose one model fit
rsf_fits <- read_rds(paste0(proj_path, "/output/rsf_hr_fits_test.rds"))

fit <- rsf_fits[which(rsf_fits$bird_id == id_sel),]

data_bird <- fit$data[[1]]

center_factors <- data_bird %>% 
    dplyr::select(dist, srtm, slope, vrm3) %>% 
    map(~attr(.x, "scaled:center")) %>% 
    unlist()

sd_factors <- data_bird %>% 
    dplyr::select(dist, srtm, slope, vrm3) %>% 
    map(~attr(.x, "scaled:scale")) %>% 
    unlist()

coef_bird <- coefficients(fit$fits[[1]])

log_pref <- coef_bird["srtm"] / sd_factors["srtm"] * srtm + 
    coef_bird["slope"] / sd_factors["slope"] * slope + 
    coef_bird["vrm3"] / sd_factors["vrm3"] * vrm3 + 
    coef_bird["dist"] / sd_factors["dist"] * dist

plot(log_pref, col = viridis::viridis(50)); title("Log selection surface")
#plot(st_geometry(st_transform(trk, crs = 4326)), add = T)

```

    6. Exponentiate and normalize predictions to calculate selection values
    
    7. Extract selection values at the observed locations
    
    8. Take log of selection at, and sum across, all observed locations.
    
    9. Repeat this process for all models and birds.
    

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# Load model fits
fits <- list(colony = read_rds("output/rsf_colony_fits_test.rds"),
             hr = read_rds("output/rsf_hr_fits_test.rds"),
             ssf = read_rds("output/ssf_fits_test.rds"))
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# Define available area ---------------------------------------------------

# I am going to define an area of 200 km around colonies

future::plan("multiprocess")
test_data <- test_data %>% 
    mutate(av_area = future_map(test_data$colony, ~ st_buffer(x = .x, dist = 200000)))
future::plan("sequential")

# Load rasters and predict ------------------------------------------------

source("R/functions/loadCovtsRasters.R")

# Create data frame to store results
cv_df <- tibble(
    target_id = character(),
    mod = character(),
    pred_id = character(),
    log_lik = double()
    )

# For each bird
for(i in 1:nrow(test_data)){
    # i <- 2
    
    target_id <- test_data$bird_id[i]
    
    a <- st_transform(test_data$av_area[[i]], crs = 4326)
    
    colony <- st_transform(test_data$colony[[i]], crs = 4326)
    
    srtm <- loadCovts(a, covt = "srtm")
    slope <- loadCovts(a, covt = "slope")
    vrm3 <- loadCovts(a, covt = "vrm3")
    
    # crop covariates
    future::plan("multiprocess")
    srtm <- future_map(srtm, ~crop(.x, a))
    slope <- future_map(slope, ~crop(.x, a))
    vrm3 <- future_map(vrm3, ~crop(.x, a))
    
    
    if(length(srtm) > 1){
        srtm <- do.call(raster::merge, srtm)
        slope <- do.call(raster::merge, slope)
        vrm3 <- do.call(raster::merge, vrm3)
    } else{
        srtm <- srtm[[1]]
        slope <- slope[[1]]
        vrm3 <- vrm3[[1]]
    }
    
    future::plan("sequential") # It's important to close multiprocess after merge otherwise temp files are lost
    
    # Calculate distance
    dist <- raster::distanceFromPoints(srtm, st_coordinates(colony))
    
    # For each of the different models calculate preference
    for(j in 1:length(fits)){
        # j <- 1
        
        mod <- names(fits)[j]
        
        fit <- fits[[j]]
        
        # Based on the models fit to each of the birds
        for(k in 1:nrow(fit)){
            # k <- 1
            
            pred_id <- fit$bird_id[k]
            
            fit_bird <- fit$fits[[k]]
            data_bird <- fit$data[[k]]
            
            center_factors <- data_bird %>% 
                dplyr::select(dist, srtm, slope, vrm3) %>% 
                map(~attr(.x, "scaled:center")) %>% 
                unlist()
            
            sd_factors <- data_bird %>% 
                dplyr::select(dist, srtm, slope, vrm3) %>% 
                map(~attr(.x, "scaled:scale")) %>% 
                unlist()
            
            coef_bird <- coefficients(fit_bird)
            
            log_pref <- coef_bird["srtm"] / sd_factors["srtm"] * srtm + 
                coef_bird["slope"] / sd_factors["slope"] * slope + 
                coef_bird["vrm3"] / sd_factors["vrm3"] * vrm3 + 
                coef_bird["dist"] / sd_factors["dist"] * dist
            
            # plot(log_pref)
            # plot(st_geometry(st_transform(test_data$data[[i]], crs = 4326)), add = T)
            
            rsf <- exp(log_pref) / cellStats(exp(log_pref), sum)
            
            lik <- raster::extract(rsf, st_coordinates(st_transform(test_data$data[[i]], crs = 4326)))
            
            log_lik <- sum(log(lik), na.rm = T)
            
            cv_df <- rbind(cv_df, tibble(target_id = target_id,
                                         mod = mod, 
                                         pred_id = pred_id,
                                         log_lik = log_lik))
        }
    }
}


```

 
In the following plot we summarize the results of the cross-validation tests:

 
```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='95%', fig.align='center', fig.show='hold'}

# Plot CV results
ggplot(cv_df) +
    geom_boxplot(aes(x = mod, y = log_lik)) +
    geom_jitter(aes(x = mod, y = log_lik), height = 0, width = 0.05, col = "red", alpha = 0.5) +
    xlab("Model") + ylab("Predicted log-likelihood") +
    facet_grid(target_id ~., scales = "free")

```

```{r, echo=FALSE}

write_rds(cv_df, "output/cv_results_tests.rds")

```


