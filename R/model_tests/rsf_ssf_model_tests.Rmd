---
title: "Cape Vulture collision risk model tests"
author: "FCervantes"
date: "8/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
options(tidyverse.quiet = TRUE)
options(sf.quiet = TRUE)
options(knitr.duplicate.label = "allow")
```

## Introduction

In this document we explore three different approaches to predicting use of space by Cape Vultures. We base predictions in resource selection models. These models analyse the preferential use of resources, by comparing those found at the used (observed) locations to those available for the bird. A key decision when modelling resource selection is the subjective choice of the area available for the bird and this question gives rise to the three different modelling approaches compared here:

**1. Availability is defined within an area around the colony**. We define colony as the point with highest density of points (we may use known colony locations when we have them). The main advantage of this option is that it availability is not constrained by the observed locations and therefore it can be set prior to seeing any data. However, we need to set a hard distance threshold to define an area around the colony, for which we probably want to look at the data. Then, there might be uncontrolled variables that hold the birds within their home range and therefore, we might be stablishing an unrealistic available range. In addition, young birds don't stay close to the colony and therefore taking the colony as a reference might not be a good option. If we were to set a threshold distance for young birds, because they can move thousands of kilometers from the colony, we would have to define an enormous area around the colony.

**2. Availability is defined within the area enclosing the observed activity of the bird**. This could be considered as selection within home range. Although this selection is at a finer scale, considering avaibility only around observed locations eases the problem of considering locations that would have never been visited by the birds, as "available". There is still some degree of subyectivity in the choice of the boundaries of the available area but, in practice, different choices would probably lead to similar results. 

**3. Availability is defined sequentially "step-by-step"**. We assume that given the sampling scheme, bird movement constrains availability to areas close to the current location. This is not to say that the birds are oblivious to what happens beyond a certain range, but that they select those steps that take him to the desired location. For example, birds might choose to select those locations that take them close to the colony (pixels characterized by distance-to-colony variable), although the colony might be beyond their reach. However, they won't be able to select an orographic slope if there are none within its reach (no pixels classified as steep within reach). With this option we let the data dictate the availability range by looking at movement characteristics, therefore eliminating the subyectivity of this choice.

The objective is to understand which of these options performs better at predicting resource selection. To do this, we fit these models to some data and predict resource selection at locations different from the one used to fit the models. We will use data from six different birds of different age, living in different areas. We analyse each bird separately to guarantee that used locations are matched only to those locations that were ever available to the birds. Note that some of these birds live thousands of kilometers away. In *step selection analysis* (model option 3) this shouldn't be an important problem, but it would be for options 1 and 2, which I will refer to as *resource selection analysis*. Then, we use the coefficients of one bird to predict resource selection for this bird and also the other birds.


```{r, echo=FALSE, message=FALSE, warning=FALSE}

# Load libraries
library(tidyverse)
library(sf)
library(raster)
library(sf)
library(furrr)
library(lubridate)
library(amt)

# Clean workspace
rm(list = ls())

# Load test data
test_data <- read_csv("data/working/test_data/test_data.csv")

# Load bird data base
db <- read_csv("data/working/bird_db.csv")

```

## Vulture data

As mentioned before, we use one year of tracking data of each of six birds of different ages. 


- Here is some basic tracking information: number of locations, average sampling frequency and standard deviation of sampling frequency,



```{r, echo=FALSE, message=FALSE, fig.align='center'}
test_data %>%     
    left_join(dplyr::select(db, bird_id, age), by = "bird_id") %>% 
    group_by(bird_id, age) %>% 
    summarize(nloc = n(),
              avg_dt = mean(dt),
              sd_dt = sd(dt))
```

<br><br>

- A tracking timeline of the birds used for the tests:

```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='75%', fig.align='center', fig.show='hold', fig.cap="Tracking timeline"}

# Plot timeline of bird tracking
test_data %>% 
    left_join(dplyr::select(db, bird_id, age), by = "bird_id") %>% 
    group_by(bird_id, age) %>% 
    summarize(date_start = min(datetime),
              date_end = max(datetime)) %>% 
    ggplot() + 
    geom_segment(aes(x = date(date_start), xend = date(date_end), 
                     y = bird_id, yend = bird_id, col = age), size = 2) + 
    geom_vline(xintercept = mdy(paste0("01/01/", 2006:2020)), 
               linetype = "dashed", colour = "grey") +
    xlab("") +
    scale_x_date(breaks = mdy(paste0("01/01/", seq(2007, 2020, 2)))) +
    theme(legend.position = "bottom",
          axis.text.y = element_text(size = 9),
          axis.text.x = element_text(size = 9))



```

<br><br>

- And the general distribution of locations:

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}

# Download Southern Africa
sa_map <- rbind(rnaturalearth::ne_states(country = "south africa", returnclass = "sf"),
                rnaturalearth::ne_states(country = "lesotho", returnclass = "sf"),
                rnaturalearth::ne_states(country = "swaziland", returnclass = "sf"),
                rnaturalearth::ne_states(country = "namibia", returnclass = "sf"),
                rnaturalearth::ne_states(country = "botswana", returnclass = "sf"))

# Remove the Prince Edward Islands
sa_map <- st_crop(sa_map, 
                  xmin = 15, xmax = 35,
                  ymin = -35, ymax = -14)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='95%', fig.align='center', fig.show='hold', fig.cap="Distribution of tracking locations"}

# Plot general tracking maps
ggplot() +
    geom_sf(data = sa_map) +
    geom_point(data = test_data, aes(x = lon, y = lat,  colour = bird_id), alpha = 0.3, size = 0.5) +
    guides(colour = guide_legend(override.aes = list(alpha = 1, size = 1.5)))


```


## Covariates

In all models we use four explanatory variables for the test: 

- distance from colony, 

- elevation, 

- slope,

- vector ruggedness index (VRM, a measure of terrain roughness).


```{r, echo= FALSE, message=FALSE, warning=FALSE}

# PREPARE DATA FOR MODEL FITTING ------------------------------------------

# Create a spatial object nested by bird
test_data <- test_data %>% 
    dplyr::select(bird_id, datetime, dt, lon, lat) %>% 
    st_as_sf(coords = c("lon", "lat"), crs = 4326, dim = "XY", remove = FALSE) %>%
    nest(data = c(-bird_id))


# Project trajectories ----------------------------------------------------

# Define projection for each data frame
source("R/functions/makeTmerProj.R")

test_data <- test_data %>% 
    mutate(tmerproj = future_map(data, ~ makeTmerProj(.x)))

# Project trajectories
test_data <- test_data %>% 
    mutate(data = future_map2(test_data$data, test_data$tmerproj, ~ st_transform(.x, crs = .y)))

# Change x and y coordinates within data frames
test_data <- test_data %>% 
    mutate(data = future_map(data, ~ mutate(.x, 
                                     x = st_coordinates(.x)[,1],
                                     y = st_coordinates(.x)[,2])))


# Find colonies -----------------------------------------------------------

source("R/functions/findColony.R")

future::plan("multiprocess")
test_data <- test_data %>% 
    mutate(colony = future_map2(test_data$data, test_data$tmerproj, ~ findColony(.x, bw = 1000, sp_proj = .y)))
future::plan("sequential")
```


```{r child = 'ch1_RSF_colony.Rmd'}
```


```{r child = 'ch2_RSF_hr.Rmd'}
```


```{r child = 'ch3_SSF.Rmd'}
```

